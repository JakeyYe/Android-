#Java反射机制
	通俗来说，反射机制就是把一个类，类的成员（函数，属性），都当成一个对
	象来操作，也就是说，类，类的成员，我们在运行时还可以动态地操作它们。

Java反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任何一个对象，都能调用它的任何一个方法和属性；

###1，Class类实例表示正在运行的Java应用程序中的类和接口（而class是Java的关键字）。枚举是一种类，注解也是一种接口。（所有类都是Class类的实例对象）

###2，通过反射机制创建类的实例对象，由于反射创建对象不能带参数，所以实例化的类一定要有无参构造函数。但是也是可以获取有参构造方法构造类实例对象的。
	Class.forName("className").newInstance();

	Constructor<?> constructors=Class.forName("className").getConstructors();//获取构造方法数组中的构造方法顺序是与类中构造方法顺序刚好相反的，构造方法顺序第一个是0
	Car car3=(Car)constructors[0].newInstance("BMW",1);


###反射机制使用场景：
	1，工厂方法模式：Factory类中用反射的话，添加一个新的类，就不需要修改工厂类Factory了。

	2，数据库JDBC中通过Class.forName(Driver)来获取数据库连接驱动。

	3，分析类文件：毕竟能得到类中的方法等等。

	4，访问一些不能访问的变量或属性：破解别人代码。

参考：[博客1](http://blog.csdn.net/ljphhj/article/details/12858767)

[反射进阶，编写反射代码值得注意的诸多细节 \- frank 的专栏 \- CSDN博客](http://blog.csdn.net/briblue/article/details/76223206)

----------------------------------------------------------

1，反射慢的原因：

反射是动态地对类型，方法进行解析，肯定是会比直接调用慢一点。

- 编译器不对反射做任何优化，因为反射涉及动态解析的类型，所以不能执行某些Java虚拟机优化；
- 反射用到的东西是需要查找的；
- 参数的装箱/拆箱



反射耗时的多少与被反射类的大小有关系，它本质上就是对类的成员列表进行遍历。如果这个类的成员越多，遍历的时间将越长
    
 整个反射的时间也就越长，如果类的成员较少，那么影响也就较小。	

 反射：原理上就是根据类名而不实例化对象的情况下（只要获取类的运行时Class对象即可），获得对象的属性或方法而直接调用。

2，说明

通过反射访问方法比实例慢很多；

有用到反射的类不能被混淆；

反射存在性能问题，但使用不频繁，按需使用时，对程序性能的影响并不大；

发射存在安全性问题，因为可以随意修改类的所有状态和行为（包括private方法和实例）；

使用反射访问Android的API时需要注意因为不同API版本导致的兼容性问题；